# Singleton

- Имеет плохую репутацию, но мне кажется, что зря. Это - просто инструмент решения тех или иных проблем. Если он их решает, то инструмент хороший, если не решает или решает не эффективно, то - плохой
- Хорошая реализация синглтона - через класс [Lazy<T>](https://learn.microsoft.com/en-us/dotnet/framework/performance/lazy-initialization), потому что .Value всегда возвращает тот же экземпляр, и в самом классе позаботились о потоко-безопасности и других вещах
- Проблема самой базовой реализации синглтона вида public static T Instance в том, что при такой реализации начинает нарушаться DIP. Например, высокоуровневая сущность начинает зависеть от конкретной реализации БД(синглтона), но эта проблема достаточно легко решается рядом способов(Правильной инъекцией зависимостей, например)
- DI фреймворки часто регистрируют типы с временем жизни Singleton, в этом ничего плохого нет. В целом самый лучший подход к использованию синглтона - делать его там, где необходимо по логике приложения(одна бд, одна фабрика, один провайдер, один сервис), регистрировать и получать его по контракту через DI фреймворк. Тогда не будет проблем с тестированием и в целом будет низкая связанность кода
- К синглтону есть дополнение в виде паттерна Multiton. Он в целом маленький, смысл в объединении пула объектов и синглтона. Хорошо написал про него Андрей Веселов [в своем блоге](https://andrey.moveax.ru/post/patterns-oop-creational-multiton)
- К синглтону есть дополнение в виде паттерна Monostate. Лично мне он кажется крайне опасным, я бы никогда его не использовал. Ознакомиться можно [тут](https://giannisakritidis.com/blog/Monostate-and-Default-interface-implementation/). Идея в том, клиент не знает, что работает с синглтоном. По прежнему создаются инстансы объекта, однако эти инстансы делят между собой статическое общее состояние. Соответственно, главная проблема в том, что клиент не знает об этом, и работает с моностейтом как с обычным объектом
- В общем и целом в текущих реалиях нет смысла создавать синглтон своими руками. Гораздо лучше контролировать время жизни объекта через DI фреймворк, что и является стандартом индустрии
